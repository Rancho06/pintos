       	       	    +---------------------------+
		    |		CS 140		|
		    | PROJECT 3: VIRTUAL MEMORY	|
		    |	   DESIGN DOCUMENT	|
		    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Shu Zhou <shuzhou@usc.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct frame {
	void* frame_addr;
	void* page_addr;
	struct thread* thread;
	bool loaded;
	struct list_elem elem;
};
Represents an individual frame page in the frame table. Has member variables of its frame address, the page_address mapped, the thread to which it belongs, and a boolean indicates whether this frame has been loaded data.

enum src_type {
	FILE,
	SWAP,
	STACK
};
Represents whether this page should load data from File, Swap or Stack.


struct page {
	void* page_addr;
	enum src_type src;
	struct file* executable;
	off_t offset;
	uint32_t read_bytes;
	bool writable;
	int swap_num;
	struct list_elem elem;
};
Represents individual page entry in the page table. Some of the member variables are required by loading from files, some are required by loading from swap blocks.


---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

This is easy since my frame structure contains a page_address pointer which contains the address of the mapped page. So given a page structure, you just iterate through all the frame table to find a frame whose page_addr is equal to the input page's address.


>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?
I didn't explicitly use access and dirty bits in my code, but use pagedir as a media. I didn't come across this issue in my code.



---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?
I added a lock in my frame.c called table_lock to synchronize potential race conditions. Whoever first gets the table_lock prevents the other from accessing the frame table.


---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?
The page structure contains many more data than the frame structure does in my implementation. Because a frame doesn't need to know all the details. Note that a frame basically is only a physical address which should have an owner (thread), and knows which virtual user address it's currently mapping to. We don't actually remove the frame structure from the frame table but simply change the internal information such as owner thread and user address, etc. This way, page structure provides the detailed and complete information about everything we know about a page, and we can bridge page and frame perfectly using the page_addr and frame_addr mapping.


		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

void load_data_from_swap(int, void *);
int write_data_to_swap(void *);
I didn't add a complete new structure for swapping, but add an interface for interacting with the block device. The two functions here are load_data_from_swap which helps read data from the swap slot to the frame page, and write_data_to_wap to help store data to the swap slot.



---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.
So I uses two passes for searching for the frame to evict.
During the first pass, I check whether there is a frame belongs to a dead thread. It there is, we just evict that frame. If there isn't, we check whether there is a frame that finishes loading and hasn't been accessed recently by checking the access bit.
If we didn't find a match in the first pass, we iterate the frame table again and finds anything that belongs to a dead thread (since some time has passed), and any thread that has finished loading process.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

First we need to clean the pagedir of Q since that mapping does not exist any more. If it is dirty or swapped before, we need to write it to swap and set Q's data source to SWAP. When the eviction finishes, we set the frame's page_addr to P's address and its thread to P. Then we add this mapping in P's pagedir table and reflect in page P's frame_addr.


>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)
I used a table_lock in frame.c, a file_lock in frame.h to help synchronize the access to frame table and the access to file system. To be notice, another shared resource is swap slots. But I didn't add synchronization to that because according to the documentation in block.c, these functions are internally synchronized. So we don't have to add a synchronization layer outside of it.


>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?
I first clean the pagedir of Q so that mapping doesn't exist. Then I write Q's data back to swap if it's dirty or swapped before. In the eviction process I used a table_lock to restrict the access so that Q will be blocked by P in this case. There is no way to be a race condition here.


>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

I added a boolean called loaded, which indicates whether a frame has already finished loading the data. In my eviction algorithm, we can never evict a frame that has not finished loading the data. So the interfere is impossible in my implementation.


>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

I used page faults to bring in pages for the first time. Then I marked that page as cannot be evicted, so that it will exist throughout the syscall process.


---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

I used two locks in my implementation, so I think I should sit between the limit and high parallelism mentioned above. In my implementation I refined my code in the way that no thread will hold a lock while waiting for another. Since hold and wait is a requirement for deadlock happening, so I make sure my code will never go into a deadlock in this case.

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.