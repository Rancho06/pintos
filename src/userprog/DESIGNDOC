		     +--------------------------+
       	       	     |		CS 140		|
		     | PROJECT 2: USER PROGRAMS	|
		     | 	   DESIGN DOCUMENT     	|
		     +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Shu Zhou <shuzhou@usc.edu>


---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct arg {
  int first;              /* start index in the whole string */
  int last;               /* end index in the whole string*/
  char* location;         /* start address in the stack */
  struct list_elem elem;  /* used for adding to a argument list */
};

purpose: to store the information about each individual argument(string), to be used later when loading to the stack in start_process().



---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

I implemented a function named break_down_args(struct list* list, const char* file_name). It detects white spaces and seperate the entire commandline string into separate individual strings. Then it constructs each individual string into the arg sturct I declared. Then I add all these arg structs to a list and use this list to set up the stack.

To ensure the right order, I will push from the end of the list, which means that the last added argument is pushed first. I will start from PHYS_BASE and decrement stack pointer every time before pushing.

At last, I will check whether the total space used exceeds the PGSIZE. If it does, the new process should be terminated properly.



---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?
Sorry, I didn't implement using any of those, but I am guessing it's probably because of synchronizing issues?


>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

1st advantage: Kernal doesn't need to separate commands itself, which improves the efficiency of the kernal. Unix can also help filter some unsafe commands I think.

2nd advantage: Unix shell is more flexible for file paths since it can be used with system PATH variable. But it is more difficult for kernal to parse to get the same effect.


			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.
// syscall.c
static int count = 2; // for file descriptor incrementing
purpose: to increment every time to make sure file descriptor is unique.

// syscall.h
struct lock lock;
purpose: used to prevent simultaneous access to file system.


>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

When I call SYS_OPEN, I create a new file and assign a unique file descriptor with this file. Then I increment the file descriptor by 1 to make sure the file descriptor is different each time.
In my design, file descriptors are unique within the entire OS.


---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

1. I first check whether the user access memory is valid.
2. Then I check whether it is an invalid read/write case, which includes invlaid fd, negative size, and null buffer.
3. Then I check the console read/write case.
4. Then I check the general case to see whether this file descriptor exists and is valid.
5. read/write if the file corresponding to the fd exits and use synchronization to protect the access.



>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

No matter whether it's 4096 bytes or 2 bytes:
Least possible number: 1; 
Greatest possible number: 2;

I didn't do any improvement about this issue in my design because I don't see any necessity in doing so. I will let page_fault to handle that.



>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

I first check whether the threads needing to be waited is a child of the current thread because only the parent can wait for the child.
Then I calls sema_down and block the parent.
When the child process terminates, in process_exit(), it will sema_up and unblock the parent process.
Then I wait until the status of child is THREAD_DYING and release the child structure from the list.



>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

The pintos document provides us two possible options. I evaluated them and chose the first option.
I implement a function called validate in syscall.c, which will validate pointer values. Basically it just checks whether the pointer value < PHYS_BASE by calling is_user_vaddr(). if bad pointer does happen, I will set exit code to -1 and calls thread_exit. Notice that for user programs, thread_exit will call process_exit(), which is where I deallocate all the dynamic allocated memories.


---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

In process_exec(), we call the thread_create() and return a tid.
if the returned tid is TID_ERROR, we return -1 as the exec() is failure.
if the returned tid is valid tid, I block the parent by calling sema_down and let the child process load.
When child process loads successfully, it will sema_up and unblock the parent. if it loads failure, it will first set the flag load_fail to true and then sema_up and unblock the parent.
When parent process gets running in process_exec, it will check load_fail and return -1 if load_fail is true.


>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

P calls wait(C) before C exits:
P will be blocked by semaphore and waits until C released semaphore and die.

P calls wait(C) after C exits:
Since C exits will remove C from P's child list, so wait(C) will do nothing.

P terminates before C:
set the parent_id of C to be -1, which means C is an orphan.

P terminates after C:
this case is normal, nothing special.


---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

I chose the first option suggested in pintos document because the second option is rather complicated and inefficient.
In my design, I basically check whether that pointer is in valid user space, but does not do any deeper checkings. If a memory error comes, I will let page_fault() to handle that. This way is easy to implement and faster in speed.



>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

I think it is just trade-off.
Advantage: 
1. the file descriptors are globally unique so don't need to waste time on making sure whether the assigned number is not the same as any existing file descriptor.
2. I include file descriptor in the file struct, so don't need to waste space to set up a mapping.

Disadvantage: 
1. file descriptor number keeps incrementing in the entire OS, which means that after a long time or a lot of user programs, the numbers may get to be very large, or even may have the possibility of overflowing.
2. Because I don't have a mapping, when we use file descriptor to get a file, we need to iterate through the current open file lists, which is O(n) in time.


>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

In my design, I didn't do any thing related to tid_t to pid_t mapping. I didn't change it.

